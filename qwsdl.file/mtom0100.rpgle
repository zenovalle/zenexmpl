      /IF NOT DEFINED(PROTOTYPE_MTOM01001)
      /DEFINE GENERATOR_SERIALIZERS
      *======================================================================
      *  Generated by WSDL2RPG 1.16.5 / 08.03.2017
      *  Built on Nov 1, 2017 (14:27:35)
      *  Built for V7R1M0
      *  Based on WS_OPER 1.16.5 - 08.03.2017
      *======================================================================
      *
      *   This source member is the RPG web service stub of the
      *   following Web Service operation:
      *
      *      Port      :  ArchiveServerPort
      *      Operation :  archiveFile()
      *
      *   Please search for 'INFO:' to get basic information how to call
      *   the web service.
      *
      *   Default attachment handling (for demonstration) was added to
      *   WS_OPER but is disabled by default.
      *
      *   In order to enable or disable default attachment handling you have
      *   to define or undefine the following compiler condition name:
      *      DEFAULT_ATTACHMENT_HANDLING
      /DEFINE DEFAULT_ATTACHMENT_HANDLING
      *
      *   By default attachments are stored in folder:
      *      '/tmp/attachments'
      *
      *   You can change the default attachment folder by calling the
      *   following procedure before calling the web service:
      *      ArchiveServerPort_Attachments_setFolder()
      *
      *   Default attachment handling was added to demonstrate how
      *   to manage attachments. Please search the generate stub
      *   module for 'TODO:' to see what code belongs to attachment
      *   support.
      *
      *======================================================================
      *   Pre-Compiler tags used by STRPREPRC to retrieve creation
      *   commands from the source member.
      * ---------------------------------------------------------------------
      * >>PRE-COMPILER<<
      *   >>CRTCMD<< CRTRPGMOD    MODULE(&LI/&OB) +
      *                           SRCFILE(&SL/&SF) +
      *                           SRCMBR(&SM);
      *   >>COMPILE<<
      *     >>PARM<< TRUNCNBR(*NO);
      *     >>PARM<< DBGVIEW(*LIST);
      *     >>PARM<< OPTION(*EVENTF);
      *   >>END-COMPILE<<
      *   >>EXECUTE<<
      * >>END-PRE-COMPILER<<
      *======================================================================
     H NOMAIN
     H DEBUG
     H OPTION(*SRCSTMT : *NODEBUGIO)
     H EXTBININT(*YES)
      *
      *  Do not change or remove this compiler condition!
      /DEFINE NO_CONST_ON_INPUT_PARAMETERS
      /ENDIF
      /IF NOT DEFINED(PROTOTYPE_DEFINED_MTOM01001)
      /DEFINE PROTOTYPE_DEFINED_MTOM01001
      *
      * INFO:
      * This is the procedure you call to consume the Web Service:
      * ----------------------------------------------------------
      * Operation: archiveFile
      * Returns  : archiveFileResponse
      *
      * INFO:
      * Define your own fields using the type templates used in the prototype
      * below. Use LIKE(*_t) or LIKEDS(*_t) to define these fields.
      * All type templates of this web service are defined in web service
      * module:   MTOM01
      *
     D ArchiveServerPort_archiveFile...
     D                 PR                  likeds(tns_archiveFileResponse_t)
     D                                     extproc('ArchiveServerPort_archiveFi+
     D                                     le')
     D  i_tns_archiveFile...
     D                                     likeds(tns_archiveFileRnmd_t)
      /IF NOT DEFINED(NO_CONST_ON_INPUT_PARAMETERS)
     D                                     const
      /ENDIF
     D  o_msg                              like(wsdl_errText_t )
      *
      * This procedure adds a file attachment. The attachment
      * is sent to the server the next time the web service is called.
     D ArchiveServerPort_...
     D archiveFile_...
     D Attachments_addFile...
     D                 PR                        like(wsdl_partID_t)
     D                                     extproc('+
     D                                     ArchiveServerPort_+
     D                                     archiveFile_+
     D                                     Attachments_addFile+
     D                                     ')
     D  i_path                             const like(wsdl_path_t)
     D  i_contentType                      const like(wsdl_contentType_t)
     D  i_transferEncoding...
     D                                     const like(
     D                                           wsdl_contentTransferEncoding_t)
     D                                           options(*nopass: *omit)
     D  i_suggestedFileName...
     D                                     const like(wsdl_path_t)
     D                                           options(*nopass: *omit)
      *
      * This procedure adds a buffer attachment. The attachment
      * is sent to the server the next time the web service is called.
     D ArchiveServerPort_...
     D archiveFile_...
     D Attachments_addBuffer...
     D                 PR                        like(wsdl_partID_t)
     D                                     extproc('+
     D                                     ArchiveServerPort_+
     D                                     archiveFile_+
     D                                     Attachments_addBuffer+
     D                                     ')
     D  i_name                             const like(wsdl_path_t)
     D  i_pBuffer                      *   const
     D  i_size                       10I 0 const
     D  i_contentType                      const like(wsdl_contentType_t)
     D  i_transferEncoding...
     D                                     const like(
     D                                           wsdl_contentTransferEncoding_t)
     D                                           options(*nopass: *omit)
     D  i_targetCcsid                10I 0 const options(*nopass: *omit)
      *
      * This procedure adds a string attachment. The attachment
      * is sent to the server the next time the web service is called.
     D ArchiveServerPort_...
     D archiveFile_...
     D Attachments_addString...
     D                 PR                        like(wsdl_partID_t)
     D                                     extproc('+
     D                                     ArchiveServerPort_+
     D                                     archiveFile_+
     D                                     Attachments_addString+
     D                                     ')
     D  i_name                             const like(wsdl_path_t)
     D  i_string                  32767A         varying options(*varsize)
     D  i_contentType                      const like(wsdl_contentType_t)
     D  i_transferEncoding...
     D                                     const like(
     D                                           wsdl_contentTransferEncoding_t)
     D                                           options(*nopass: *omit)
     D  i_targetCcsid                10I 0 const options(*nopass: *omit)
      *
 CPY  /COPY QWSDL2RPG,TYPES_H
      *
      /DEFINE PROTOTYPE_MTOM01
 CPY  /COPY ZENEXMPL/QWSDL,MTOM01                  Web Service: Web Service Proc
      /UNDEFINE PROTOTYPE_MTOM01
      *
      /ENDIF
      /IF DEFINED(PROTOTYPE_MTOM01001)
      /EOF
      /ENDIF
      * ---------------------------------------------------------------------
      *
      *
 CPY  /COPY QBASICS1,PBASICS1                      Tools/400 Runtime Library
 CPY  /COPY QMIME,PMIME                            Tools/400 MIME Parser
 CPY  /COPY QMIME,HTTPMIME_H                       Tools/400 MIME Parser to HTTP API adapter
 CPY  /COPY QRPGLESRC,HTTPAPI_H                    HTTP-API Service Program
 CPY  /COPY QWSDL2RPG,PWSDL2R70                    WSDL2RPG: HTTP API Header Extensions
 CPY  /COPY QWSDL2RPG,PWSDL2R71                    WSDL2RPG: HTTP Debug Log
 CPY  /COPY QWSDL2RPG,PWSDL2R79                    WSDL2RPG: Static Array
 CPY  /COPY QWSDL2RPG,PWSDL2R85                    WSDL2RPG: MessageContext
 CPY  /COPY QWSDL2RPG,PWSDL2R86                    WSDL2RPG: Stream
 CPY  /COPY QWSDL2RPG,PWSDL2R87                    WSDL2RPG: ManagedMemoryDataSource
 CPY  /COPY QWSDL2RPG,PWSDL2R88                    WSDL2RPG: Public Helper Procedures
 CPY  /COPY QWSDL2RPG,PWSDL2R90                    WSDL2RPG: AppMsg
 CPY  /COPY QWSDL2RPG,PWSDL2R94                    WSDL2RPG: MultiRef
 CPY  /COPY QWSDL2RPG,PWSDL2R97                    WSDL2RPG: eXpat Adapter
 CPY  /COPY QWSDL2RPG,PWSDL2R98                    WSDL2RPG: UnMarshaller/Marshaller
 CPY  /COPY QWSDL2RPG,PWSDL2R42                    WSDL2RPG: User name and password
      *
      * ------------------------------------
      *  Internal prototypes
      * ------------------------------------
      *
      *   Reopens a given input stream in order to send it over
      *   the wire again.
     D reOpenInputStream...
     D                 PR                         like(wsdl_hStream_t    )
     D                                     extproc('+
     D                                     reOpenInputStream+
     D                                     ')
     D  i_hMsgCtx                          const  like(wsdl_hMsgCtx_t    )
     D  i_hInpStream                       value  like(wsdl_hStream_t    )
      *
      *   Login in to proxy server or http server.
     D login...
     D                 PR            10I 0
     D                                     extproc('+
     D                                     login+
     D                                     ')
      *
      *   Sets the content type and the SOAP action of the POST message.
     D HTTP_setContentTypeAndSOAPAction...
     D                 PR
     D                                     extproc('+
     D                                     HTTP_setContentTypeAndSOAPAction+
     D                                     ')
     D  o_addlHdrs                 1024A          varying
     D  i_pUserData                    *   value
      *
      *
      * Message serializer for element or type:
      * tns:archiveFile
     D tns_archiveFileRnmdSerializer...
     D                 PR
     D                                     extproc('tns_archiveFileRnmdSerializ+
     D                                     er')
     D  i_hOutStream                       like(wsdl_hStream_t)
     D                                     const
     D  i_tns_archiveFileRnmd...
     D                                     likeds(tns_archiveFileRnmd_t)
     D  i_elemName                         like(wsdl_name_t)
     D                                     const
      *
      * Message serializer for element or type:
      * tns:request
     D tns_archiveRequestSerializer...
     D                 PR
     D                                     extproc('tns_archiveRequestSerialize+
     D                                     r')
     D  i_hOutStream                       like(wsdl_hStream_t)
     D                                     const
     D  i_tns_archiveRequest...
     D                                     likeds(tns_archiveRequest_t)
     D  i_elemName                         like(wsdl_name_t)
     D                                     const
      *
     D tns_archiveFileResponseRnmdStart...
     D                 PR
     D                                     extproc('tns_archiveFileResponseRnmd+
     D                                     Start')
     D  userdata                       *   value
     D  depth                        10I 0 value
     D  namespace                  1024A   varying const
     D  name                       1024A   varying const
     D  path                      24576A   varying const
     D  attrs                          *   dim(32767)
     D                                     const options(*varsize)
     D tns_archiveFileResponseRnmdEnd...
     D                 PR
     D                                     extproc('tns_archiveFileResponseRnmd+
     D                                     End')
     D  userdata                       *   value
     D  depth                        10I 0 value
     D  namespace                  1024A   varying const
     D  name                       1024A   varying const
     D  path                      24576A   varying const
     D  value                     65535A   varying
     D  attrs                          *   dim(32767)
     D                                     const options(*varsize)
      *
      *   Append a given data buffer to the specified output stream.
     D OutputStream_appendBuffer...
     D                 PR                  extproc('+
     D                                     OutputStream_appendBuffer+
     D                                     ')
     D  i_hStream                          value  like(wsdl_hStream_t)
     D  i_data                         *   value
     D  i_length                     10I 0 value
      *
      *   Append the content of the global request buffer
      *   (g_requestBuffer) to the specified output stream
      *   and afterwards clears the buffer.
     D OutputStream_appendGlobalRequestBuffer...
     D                 PR                  extproc('+
     D                                     OutputStream_+
     D                                     appendGlobalRequestBuffer+
     D                                     ')
     D  i_hStream                    10I 0 value
     D  io_requestBuffer...
     D                            65535A          varying options(*varsize)
      *
      *   Receive response of Hendif;
     D HTTP_receiveResponse...
     D                 PR            10I 0 extproc('+
     D                                     HTTP_receiveResponse+
     D                                     ')
     D  i_hStream                    10I 0 value
     D  i_data                         *   value
     D  i_length                     10I 0 value
      *
      *   Parses or redirects the web service response.
     D parseOrRedirectResponse...
     D                 PR              N   extproc('+
     D                                     parseOrRedirectResponse+
     D                                     ')
     D  i_data                         *   value
     D  i_length                     10I 0 value
      *
      *   SOAP message: Envelope
     D SOAPMessage_Envelope...
     D                 PR                  extproc('+
     D                                     SOAPMessage_Envelope+
     D                                     ')
     D   userdata                      *   value
     D   depth                       10I 0 value
     D   namespace                 1024A   varying const
     D   name                      1024A   varying const
     D   path                     24576A   varying const
     D   attrs                         *   dim(32767)
     D                                     const options(*varsize)
      *
      *   SOAP message: fault information
     D SOAPMessage_FaultStart...
     D                 PR                  extproc('+
     D                                     SOAPMessage_FaultStart+
     D                                     ')
     D   userdata                      *   value
     D   depth                       10I 0 value
     D   namespace                 1024A   varying const
     D   name                      1024A   varying const
     D   path                     24576A   varying const
     D   attrs                         *   dim(32767)
     D                                     const options(*varsize)
      *
      *   SOAP message: fault information
     D SOAPMessage_FaultEnd...
     D                 PR                  extproc('+
     D                                     SOAPMessage_FaultEnd+
     D                                     ')
     D   userdata                      *   value
     D   depth                       10I 0 value
     D   namespace                 1024A   varying const
     D   name                      1024A   varying const
     D   path                     24576A   varying const
     D   value                    65535A   varying const
     D   attrs                         *   dim(32767)
     D                                     const options(*varsize)
      *
      *   SOAP message: fault details
     D SOAPMessage_FaultDetailStart...
     D                 PR                  extproc('+
     D                                     SOAPMessage_FaultDetailStart+
     D                                     ')
     D   userdata                      *   value
     D   depth                       10I 0 value
     D   namespace                 1024A   varying const
     D   name                      1024A   varying const
     D   path                     24576A   varying const
     D   attrs                         *   dim(32767)
     D                                     const options(*varsize)
      *
      *   SOAP message: fault details
     D SOAPMessage_FaultDetailEnd...
     D                 PR                  extproc('+
     D                                     SOAPMessage_FaultDetailEnd+
     D                                     ')
     D   userdata                      *   value
     D   depth                       10I 0 value
     D   namespace                 1024A   varying const
     D   name                      1024A   varying const
     D   path                     24576A   varying const
     D   value                    65535A   varying const
     D   attrs                         *   dim(32767)
     D                                     const options(*varsize)
      *
      *   SOAP message: NULL callback procedure
     D SOAPMessage_unexpectedElementStart...
     D                 PR
     D                                     extproc('+
     D                                     SOAPMessage_unexpectedElementStart+
     D                                     ')
     D   userdata                      *   value
     D   depth                       10I 0 value
     D   namespace                 1024A   varying const
     D   name                      1024A   varying const
     D   path                     24576A   varying const
     D   attrs                         *   dim(32767)
     D                                     const options(*varsize)
      *
      *   SOAP message: NULL callback procedure
     D SOAPMessage_unexpectedElementEnd...
     D                 PR
     D                                     extproc('+
     D                                     SOAPMessage_unexpectedElementEnd+
     D                                     ')
     D   userdata                      *   value
     D   depth                       10I 0 value
     D   namespace                 1024A   varying const
     D   name                      1024A   varying const
     D   path                     24576A   varying const
     D   value                    65535A   varying const
     D   attrs                         *   dim(32767)
     D                                     const options(*varsize)
      *
     D ignoreUnexpectedSoapHeader...
     D                 PR              N
     D                                     extproc('+
     D                                     ignoreUnexpectedSoapHeader+
     D                                     ')
      *
     D getOperationUuid...
     D                 PR                          like(wsdl_uuid_t )
     D                                     extproc('+
     D                                     getOperationUuid+
     D                                     ')
      *
     D getPortName...
     D                 PR                          like(wsdl_portName_t )
     D                                     extproc('+
     D                                     getPortName+
     D                                     ')
      *
     D getOperationName...
     D                 PR                          like(wsdl_operName_t )
     D                                     extproc('+
     D                                     getOperationName+
     D                                     ')
      *
     D getPostCcsid...
     D                 PR            10I 0
     D                                     extproc('+
     D                                     getPostCcsid+
     D                                     ')
      *
     D getPostCcsidXml...
     D                 PR            20A   varying
     D                                     extproc('+
     D                                     getPostCcsidXml+
     D                                     ')
      *
     D getTimeout...
     D                 PR            10I 0
     D                                     extproc('+
     D                                     getTimeout+
     D                                     ')
      *
     D getUserAgent...
     D                 PR                         like(wsdl_userAgent_t )
     D                                     extproc('+
     D                                     getUserAgent+
     D                                     ')
      *
     D getMessageContext...
     D                 PR                         like(wsdl_hMsgCtx_t)
     D                                     extproc('+
     D                                     getMessageContext+
     D                                     ')
      *
     D mustRedirectStmf...
     D                 PR              N
     D                                     extproc('+
     D                                     mustRedirectStmf+
     D                                     ')
      *
      * ------------------------------------
      *  Global fields & constants
      * ------------------------------------
      *
      *   Release, the client stub was compiled for
     D COMPILED_FOR...
     D                 C                   'V7R1M0'
      *
      *   UUID of the web service operation as generated by WSDL2RPG
      *   (Using UUID of web service port for all operations by default)
      *cOPERATION_UUID...
      *                C                   '0D46E001EB7119FF9FDD0004AC18DB29'
      *
      *   CCSID critical characters
     D SQUARE_BRACKET_LEFT...
     D                 S              1A
     D SQUARE_BRACKET_RIGHT...
     D                 S              1A
     D QUOTE...
     D                 S              1A
      *
      *   SOAP response header
      *
      *   Reference to the 'respSoapHeader' field.
     D g_pRespSoapHeader...
     D                 S               *   inz
      *
      *   XMLSAXParser handle
     D g_hSAXParser    S                   like(xmlSaxParser_handle_t) inz
      *
      *   MIME parser
     D g_hMIMEParser   S                   like(mime_hMime_t ) inz
      *
      *   MIME message indicator
     D g_isMimeMessage...
     D                 S               N   inz(cFalse)
      *
      *   Content ID of the SOAP message part
     D g_SOAPMessageID...
     D                 S            512A   varying inz
      *
      *   Indicator "parse SOAP message"
     D g_doParseSOAPMessage...
     D                 S               N   inz(cFalse)
      *
      *   Indicator "SOAP message parsed"
     D g_SOAPMessage_done...
     D                 S               N   inz(cFalse)
      *
      *   Body part counter
     D g_BodyPart_counter...
     D                 S             10I 0 inz
      *
      *   HTTP response "initialized" indicator
     D g_HTTP_isInit...
     D                 S               N   inz(cFalse)
      *
      *   Error information of web service operation
     D g_errors        DS                  likeds(wsdl_errors_t    ) inz
      *
      *   Switch for AXIS bug AXIS-2095
     D g_isAXIS_2095   S               N   inz(cFalse)
      *
      *   Message context
     D g_hMsgCtx       S                   like(wsdl_hMsgCtx_t) inz
      *
      *   Global buffer to build the request message.
     D g_requestBuffer...
     D                 S          65535A   varying inz
      *
      * -------------------------------------------
      *  TODO: Added to implement default
      *        attachment handling.
      * -------------------------------------------
      /IF DEFINED(DEFAULT_ATTACHMENT_HANDLING)
 CPY  /COPY QWSDL2RPG,CLIB                         C Runtime Library
      *
      *  User data scoped to the current part
     D partUserData_t...
     D                 DS                  qualified               based(pDummy)
     D  FD                           10i 0
      *
      /ENDIF
      * =====================================================================
      * Operation: archiveFile
      * Returns  : archiveFileResponse
      * =====================================================================
     P ArchiveServerPort_archiveFile...
     P                 B                   export
     D                 PI                  likeds(tns_archiveFileResponse_t)
     D  i_tns_archiveFile...
     D                                     likeds(tns_archiveFileRnmd_t)
     D  o_msg                       128A   varying
      *
      *  Return value
     D rtnValue        DS                  likeds(tns_archiveFileResponse_t)
     D                                     inz
      *
      *  Local fields
     D isUnexpectedError...
     D                 S               N   inz(cFalse)
     D url             S          32767A   varying
     D http_rc         S             10I 0 inz
     D rcvm0200        DS                  likeds(rcvm0200_t    ) inz
     D msg             DS                  likeds(msg_t         ) inz
     D headers         DS                  likeds(wsdl_headers_t) inz
      *
     D hMsgCtx         S                   like(wsdl_hMsgCtx_t       ) inz
     D hSoapPart       S                   like(wsdl_hDataSource_t   ) inz
     D hOutStream      S                   like(wsdl_hStream_t       ) inz
     D hSAXParser      S                   like(xmlSaxParser_handle_t) inz
     D hMIMEParser     S                   like(mime_hMime_t         ) inz
     D hInpStream      S                   like(wsdl_hStream_t       ) inz
     D contentType     S                   like(wsdl_contentType_t   ) inz
      *
      *   Proxy server to use
     D httpProxy       DS                  likeds(wsdl_proxy_t     ) inz
      *
      *  Login helper fields
     D err             S             10I 0 inz
      *
      *  User data
     D userData        DS                  likeds(tns_archiveFileResponse_t)
     D                                     inz
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /free

         o_msg = '';

         SQUARE_BRACKET_LEFT = %char(u'005B');
         SQUARE_BRACKET_RIGHT = %char(u'005D');
         QUOTE = %char(u'0022');  // double quote
         // QUOTE = %char(u'0027');

         monitor;

            // Initialize web service stub
            ArchiveServerPort_Port_initialize(
                  getOperationName());

            // Enable/disable HTTP debug log
            // Starting with v1.15 the debug log is started in
            // procedure http_DebugLog_open() which is called by
            // WebServiceStub_Port_setHttpDebug().

            http_DebugLog_appendText(
            '** ' + %char(%timestamp()) + ': Entering ' + f_this() + '()' +
            ', compiled for ' + COMPILED_FOR);

            // Initialize map to manage <multiRef> elements
            MultiRef_new();

            // Remove all attachments of this service from the list of attachments
            ArchiveServerPort_Attachments_removeAll(
                  getOperationUuid());

            // Set proxy server to use
            httpProxy = ArchiveServerPort_Port_getHttpProxy();
            http_setproxy(httpProxy.server: httpProxy.port);

            // Set CCSID for POST data according
            // to the encoding of the SOAP envelope
            HTTP_SetCCSIDs(getPostCcsid(): HTTP_EBCDIC);

            // Get (create) the message context and get the SOAP part.
            // Be sure to specify a reasonable cache size for best performance.
            // Best performance is guaranteed, when the memory cache
            // is large enough to take the complete XML request message.
            hMsgCtx = getMessageContext();
            hSoapPart = MessageContext_getSoapPart(hMsgCtx: 1024*1024*4); // 4 MB cache
            MessageContext_setSoapAction(hMsgCtx:
               ''
               );

            // Produce SOAP request message
            http_DebugLog_appendTextVerbose(
            '** ' + %char(%timestamp()) + ': Producing request messsage');

            // Open data source and write the request message to it
            contentType = 'text/xml; charset=' + getPostCcsidXml();
            hOutStream = ManagedMemoryDataSource_OutputStream_open(
                               hSoapPart: contentType: getPostCcsid());

            g_requestBuffer =
               '<?xml version=' + QUOTE + '1.0' + QUOTE                    +
                   ' encoding=' + QUOTE + getPostCcsidXml() + QUOTE + '?>' +
               '<soapenv:Envelope'                                         +
               ' xmlns:soapenv=' +
               QUOTE +
               'http://schemas.xmlsoap.org/soap/envelope/' +
               QUOTE;
            OutputStream_appendBuffer(
                  hOutStream: %addr(g_requestBuffer)+2: %len(g_requestBuffer));

            // Namespaces
            g_requestBuffer =
            ' xmlns:tns='+ QUOTE +
            'http://examples.zenovalle.it/'
             + QUOTE +
               '>';

            OutputStream_appendBuffer(
                  hOutStream: %addr(g_requestBuffer)+2: %len(g_requestBuffer));

            // SOAP header

            // Message body
            g_requestBuffer =
               '<soapenv:Body>' +
            '';

         // Add previous bytes of request message to output stream
         OutputStream_appendGlobalRequestBuffer(
            hOutStream
            : g_requestBuffer
            );

         tns_archiveFileRnmdSerializer(
            hOutStream
            : i_tns_archiveFile
            : 'tns:archiveFile'
            );

         g_requestBuffer =
               '</soapenv:Body>' +
               '</soapenv:Envelope>';

            OutputStream_appendBuffer(
                  hOutStream: %addr(g_requestBuffer)+2: %len(g_requestBuffer));

            // Close data source and prepare it to send the message
            ManagedMemoryDataSource_OutputStream_close(hOutStream);
            MessageContext_prepareToSend(hMsgCtx);

            http_DebugLog_appendTextVerbose(
            '** ' + %char(%timestamp()) + ': Finished request message');

            http_DebugLog_appendTextVerbose(
            '** ' + %char(%timestamp()) + ': Preparing to send message');

            // Clear error code
            ArchiveServerPort_Port_clearErrors(
                  g_errors);

            // HTTPAPI: Enables additional headers
            http_xproc(HTTP_POINT_ADDL_HEADER
                       : %paddr('HTTP_setContentTypeAndSOAPAction')
                       : %addr(headers));

            // HTTPAPI: Add additional message headers
            clear headers;
 B01        if (MessageContext_isMIMEMessage(hMsgCtx));
               headers.mimeVersion =
                     MessageContext_getMimeVersionHeader(hMsgCtx);
 X01        else;
               headers.mimeVersion = '';
 E01        endif;
            headers.contentType = MessageContext_getContentTypeHeader(hMsgCtx);
            headers.soapAction = MessageContext_getSoapActionHeader(hMsgCtx);

            // ---------------------------------------
            //   Post request and parse response
            // ---------------------------------------

            // Create parser (callbacks style: HTTP API)
 B01        if (not mustRedirectStmf());
               XMLSAXParser_new(hSAXParser: cTrue);
               XMLSAXParser_setStripCRLF(hSAXParser: cTrue);
               XMLSAXParser_setDoNamespaces(hSAXParser: cTrue);
               XMLSAXParser_registerCallback(hSAXParser
                  : cXML_CB_SAX_STARTELEMENT
                  : %paddr('SOAPMessage_Envelope'));
               XMLSAXParser_prepareParse(hSAXParser: %addr(userData));
 E01        endif;

            // Create MIME parser in case we need it
            hMIMEParser = MIMEParser_new();
            MIMEParser_setDecodeData(hMIMEParser: cTrue);
            http_mime_DataSink_initialize(hMIMEParser
                                          : *NULL
                                          : %paddr('HTTPDataSink_startPart')
                                          : %paddr('HTTPDataSink_bodyData')
                                          : %paddr('HTTPDataSink_endPart'));

            // Make parser available for HTTP_receiveResponse()
            g_hSAXParser    = hSAXParser;
            g_hMIMEParser   = hMIMEParser;
            g_isMimeMessage = cFalse;
            g_HTTP_isInit   = cFalse;
            g_SOAPMessageID = '';
            g_doParseSOAPMessage = cFalse;
            g_SOAPMessage_done   = cFalse;
            g_BodyPart_counter   = 0;

            // Make SOAP response header available to SOAPMessage_Envelope
            g_pRespSoapHeader = *NULL;

            // Open input stream in order to send the message
            hInpStream = MessageContext_InputStream_open(hMsgCtx);

            // eXpat: Post request and parse response
            url = ArchiveServerPort_Endpoint_get();

            // Authenticate pre-emptively, if configured
 B01        if (ArchiveServerPort_Port_isAuthenticatePreemptively());
               ArchiveServerPort_Port_authenticatePreemptively();
 E01        endif;

 B01        dou (not HttpResponse_isAuthenticationError(http_rc));
               // Get document from server and handle http redirects
               // See also: WSDL2R88.HttpResponse_isRedirect()
 B02           dou (not HttpResponse_isRedirect(http_rc));
                  http_DebugLog_appendText(
                  '** ' + %char(%timestamp()) + ': Sending request to server');

                  http_rc =
                     http_url_post_raw2(
                        url
                        : hInpStream
                        : %paddr('WSDL2R85_MessageContext_InputStream_read')
                        : MessageContext_getSize(hMsgCtx)
                        : 0
                        : %paddr('HTTP_receiveResponse')
                        : getTimeout()
                        : getUserAgent()
                        : '');

 B03              if (HttpResponse_isRedirect(http_rc));
                     url = http_redir_loc();
                     hInpStream = reOpenInputStream(hMsgCtx: hInpStream);
 E03              endif;
 E02           enddo;

 B02           if (http_rc <> 1);

                  // Get the HTTP API error code.
                  http_error(err);

                  // The first time we request a document that requires user/password
                  // it will return a HTTP_NDAUTH error.
 B03              if (HttpResponse_isAuthenticationError(http_rc));
 B04                 if (not ArchiveServerPort_Port_hasLoginCallback());
                        leave;
 E04                 endif;

 B04                 if (login() <> WSDL_SUCCESS);
                        leave;
 E04                 endif;

                     hInpStream = reOpenInputStream(hMsgCtx: hInpStream);
 E03              endif;
 X02           else;
                  MultiRef_finalize();
                  err = 0;
 E02           endif;
 E01        enddo;

            // Preserve parser error code and message text
 B01        if (err = HTTP_RDWERR);
               g_errors.xmlError.code = XMLToolkit_getError(
                                              hSAXParser
                                              : g_errors.xmlError.text
                                              : g_errors.xmlError.line
                                              : g_errors.xmlError.column);
 E01        endif;

 B01        if (not mustRedirectStmf());
               XMLSAXParser_endParse(hSAXParser);
 E01        endif;

 B01        if (g_isMimeMessage);
               MIMEParser_endParse(hMIMEParser);
               g_isMimeMessage = cFalse;
 E01        endif;

            g_HTTP_isInit = cFalse;

         on-error;
            isUnexpectedError = cTrue;
            rcvm0200 = f_rcvPgmMsg(cMsg_Any: *OMIT: cMsg_Act_Same: 0
                                   : cMsg_Same: cMsg_ToMyself);
            http_DebugLog_appendRcvMsg(rcvm0200);
            msg = f_cvtRcvMsgToMsg(rcvm0200);
            g_errors.errType        = WSDL_HTTP_ERROR_UNEXPECTED;
            g_errors.httpError.no   = WSDL_HTTP_ERROR_UNEXPECTED;
            g_errors.httpError.text = f_rtvMsgText(msg);
            http_rc = g_errors.httpError.no;
            o_msg = g_errors.httpError.text;
         endmon;

         g_hSAXParser  = *NULL;
         g_hMIMEParser = *NULL;

 B01     if (not isUnexpectedError);
 B02        if (err <> 0 or g_errors.errType <> WSDL_HTTP_SUCCESS);
 B03           if (err <> 0);
                  g_errors.errType = WSDL_HTTP_ERROR;

                  // Set http error code and message text
                  g_errors.httpError.no   = err;
                  g_errors.httpError.text = http_error();

                  // Return error message text to caller
                  o_msg = g_errors.httpError.text;
 X03           else;
                  o_msg = g_errors.soapFault.string;
 E03           endif;
               clear rtnValue;
            else;
               o_msg = '';
               rtnValue = userData;
            endif;
 E02     endif;

 B02     if (ArchiveServerPort_RedirectResponse_isActive());
            ArchiveServerPort_RedirectResponse_terminate();
 E02     endif;

 B02     if (not XMLSAXParser_isNull(hSAXParser));
            XMLSAXParser_delete(hSAXParser);
 E02     endif;

 B02     if (not MIMEParser_isNull(hMIMEParser));
            MIMEParser_delete(hMIMEParser);
 E02     endif;

 B02     if (not ManagedMemoryDataSource_isNull(hSoapPart));
 B03        if (ManagedMemoryDataSource_Stream_isOpen(hOutStream));
               ManagedMemoryDataSource_OutputStream_close(hOutStream);
 E03        endif;
            // *************************************************
            // Do not delete the the SOAP part (hSoapPart) here.
            // It is deleted by MessageContext_delete().
            // *************************************************
 E02     endif;

 B02     if (not MessageContext_isNull(g_hMsgCtx));
 B03        if (MessageContext_InputStream_isOpen(hInpStream));
               MessageContext_InputStream_close(hInpStream);
 E03        endif;
            MessageContext_delete(g_hMsgCtx);
            g_hMsgCtx = MessageContext_null();
 E02     endif;

 B02     if (not MultiRef_isNull());
            MultiRef_delete();
 E02     endif;

         // Disable preemptive authentication. The user may not want
         // to authenticate preemptively with the next call.
         ArchiveServerPort_Port_resetPreemptiveAuthentication();

         // Set error information of last service call
         ArchiveServerPort_Port_setErrors(
               g_errors);

         http_DebugLog_appendText(
         '** ' + %char(%timestamp()) + ': Leaving ' + f_this() + '()');

 B02     if (http_DebugLog_isOpen());
            http_DebugLog_close();
 E02     endif;

         return rtnValue;

      /end-free
      *
     P                 E
      *
      *
      * ==================================================================
      * Message serializer for element or type:
      * tns:archiveFile
      * ==================================================================
     P tns_archiveFileRnmdSerializer...
     P                 B
     D                 PI
     D  i_hOutStream                       like(wsdl_hStream_t)
     D                                     const
     D  i_tns_archiveFileRnmd...
     D                                     likeds(tns_archiveFileRnmd_t)
     D  i_elemName                         like(wsdl_name_t)
     D                                     const
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /free

         g_requestBuffer =
         '<' + i_elemName + '>' +
            '';

         // Add previous bytes of request message to output stream
         OutputStream_appendGlobalRequestBuffer(
            i_hOutStream
            : g_requestBuffer
            );

         tns_archiveRequestSerializer(
            i_hOutStream
            : i_tns_archiveFileRnmd.request
            : 'request'
            );

         g_requestBuffer =
         '</' + i_elemName + '>' +
            '';

         // Add previous bytes of request message to output stream
         OutputStream_appendGlobalRequestBuffer(
            i_hOutStream
            : g_requestBuffer
            );

      /end-free
      *
     P                 E
      *
      * ==================================================================
      * Message serializer for element or type:
      * tns:request
      * ==================================================================
     P tns_archiveRequestSerializer...
     P                 B
     D                 PI
     D  i_hOutStream                       like(wsdl_hStream_t)
     D                                     const
     D  i_tns_archiveRequest...
     D                                     likeds(tns_archiveRequest_t)
     D  i_elemName                         like(wsdl_name_t)
     D                                     const
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /free

         g_requestBuffer =
         '<' + i_elemName + '>' +
         '<fileLoad>' +
            '';

         // Add previous bytes of request message to output stream
         OutputStream_appendGlobalRequestBuffer(
            i_hOutStream
            : g_requestBuffer
            );

         if ElementValue_isContentId(i_tns_archiveRequest.fileLoad);
            if MessageContext_isMTOM(getMessageContext());
               g_requestBuffer =
               '<inc:Include href="' +
               i_tns_archiveRequest.fileLoad +
               '"' +
               ' xmlns:inc="http://www.w3.org/2004/08/xop/include"/>' +
                  '';

               // Add previous bytes of request message to output stream
               OutputStream_appendGlobalRequestBuffer(
                  i_hOutStream
                  : g_requestBuffer
                  );
            else;
               Marshaller_toStringV6(
                  %addr(i_tns_archiveRequest.fileLoad)
                  : %addr(i_tns_archiveRequest.fileLoad: *DATA)
                  : %len(i_tns_archiveRequest.fileLoad)
                  : i_hOutStream
                  );
            endif;
         else;
            Marshaller_toBase64BinaryV6(
               %addr(i_tns_archiveRequest.fileLoad)
               : %addr(i_tns_archiveRequest.fileLoad: *DATA)
               : %len(i_tns_archiveRequest.fileLoad)
               : i_hOutStream
               );
         endif;

         g_requestBuffer =
         '</fileLoad>' +
         '<fileName>' +
            '';

         // Add previous bytes of request message to output stream
         OutputStream_appendGlobalRequestBuffer(
            i_hOutStream
            : g_requestBuffer
            );

         Marshaller_toStringV6(
            %addr(i_tns_archiveRequest.fileName)
            : %addr(i_tns_archiveRequest.fileName: *DATA)
            : %len(i_tns_archiveRequest.fileName)
            : i_hOutStream
            );

         g_requestBuffer =
         '</fileName>' +
         '<fileType>' +
            '';

         // Add previous bytes of request message to output stream
         OutputStream_appendGlobalRequestBuffer(
            i_hOutStream
            : g_requestBuffer
            );

         Marshaller_toStringV6(
            %addr(i_tns_archiveRequest.fileType)
            : %addr(i_tns_archiveRequest.fileType: *DATA)
            : %len(i_tns_archiveRequest.fileType)
            : i_hOutStream
            );

         g_requestBuffer =
         '</fileType>' +
         '<key>' +
            '';

         // Add previous bytes of request message to output stream
         OutputStream_appendGlobalRequestBuffer(
            i_hOutStream
            : g_requestBuffer
            );

         Marshaller_toStringV6(
            %addr(i_tns_archiveRequest.key)
            : %addr(i_tns_archiveRequest.key: *DATA)
            : %len(i_tns_archiveRequest.key)
            : i_hOutStream
            );

         g_requestBuffer =
         '</key>' +
         '<description>' +
            '';

         // Add previous bytes of request message to output stream
         OutputStream_appendGlobalRequestBuffer(
            i_hOutStream
            : g_requestBuffer
            );

         Marshaller_toStringV6(
            %addr(i_tns_archiveRequest.description)
            : %addr(i_tns_archiveRequest.description: *DATA)
            : %len(i_tns_archiveRequest.description)
            : i_hOutStream
            );

         g_requestBuffer =
         '</description>' +
         '</' + i_elemName + '>' +
            '';

         // Add previous bytes of request message to output stream
         OutputStream_appendGlobalRequestBuffer(
            i_hOutStream
            : g_requestBuffer
            );

      /end-free
      *
     P                 E
      *
      * =====================================================================
      *   Append a given data buffer to the specified output stream.
      * =====================================================================
     P OutputStream_appendBuffer...
 ERR P                 B
     D                 PI
     D  i_hStream                          value  like(wsdl_hStream_t)
     D  i_data                         *   value
     D  i_length                     10I 0 value
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /free

         if (i_length > 0);
            // Add previous bytes of request message to output stream
            ManagedMemoryDataSource_OutputStream_write(
                  i_hStream: i_data: i_length);
         endif;

      /end-free
     P                 E
      *
      * =====================================================================
      *   Append the content of the global request buffer
      *   (g_requestBuffer) to the specified output stream
      *   and afterwards clears the buffer.
      * =====================================================================
     P OutputStream_appendGlobalRequestBuffer...
     P                 B
     D                 PI
     D  i_hStream                    10I 0 value
     D  io_requestBuffer...
     D                            65535A          varying options(*varsize)
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /free

         if (%len(io_requestBuffer) = 0);
            return;
         endif;

         OutputStream_appendBuffer(
            i_hStream: %addr(io_requestBuffer)+2: %len(io_requestBuffer));
         clear io_requestBuffer;

      /end-free
     P                 E
      *
      * =====================================================================
      * This procedure adds a file attachment. The attachment
      * is sent to the server the next time the web service is called.
      *
      * Parameters:
      *  i_path            Path to the file that is added as an attachment.
      *
      *  i_contentType     Specifies the type of the MIME data.
      *                    Possible values are:
      *
      *  Content type, example values:
      *
      *     application/octet-stream    executable file     *.bin *.exe *.com *.dll *.class
      *     application/pdf             Adobe PDF file      *.pdf
      *     application/rtf             Microsoft RTF file  *.rtf
      *     application/xml             XML file            *.xml
      *     application/zip             ZIP file            *.zip
      *     audio/x-mpeg                MPEG file           *.mp2
      *     image/gif                   GIF image           *.gif
      *     image/jpeg                  JPEG image          *.jpeg *.jpg *.jpe
      *     image/png                   PNG image           *.png
      *     image/tiff                  TIFF image          *.tiff *.tif
      *     text/comma-separated-values CSV file            *.csv
      *     text/rtf                    Microsoft RTF file  *.rtf
      *     text/xml                    XML file            *.xml
      *     text/plain                  Plain text file     *.txt
      *     video/mpeg                  MPEG video file     *.mpeg *.mpg *.mpe
      *
      *     See also: http://de.selfhtml.org/diverses/mimetypen.htm
      *
      *  i_contentType          Specifies the type of the MIME data.
      *
      *  i_transferEncoding     Specifies the encoding of the MIME data.
      *                         Possible values are:
      *
      *                         WSDL_MIME_BINARY - binary data, no encoding
      *                         WSDL_MIME_BASE64 - converted to base64
      *
      *  i_suggestedFileName    Is the suggested file for saving the
      *                         attachment. Goes into the
      *                         'Content-Disposition header', attribute 'filename'.
      *                         The content disposition is always 'attachment'.
      *
      * Return value:
      *  partID                 Unique ID of the attachment. Usually this ID
      *                         is stored in the SOAP message, depending on
      *                         the description of the Web Service.
      * =====================================================================
     P ArchiveServerPort_...
     P archiveFile_...
     P Attachments_addFile...
     P                 B                   export
     D                 PI                        like(wsdl_partID_t)
     D  i_path                             const like(wsdl_path_t)
     D  i_contentType                      const like(wsdl_contentType_t)
     D  i_transferEncoding...
     D                                     const like(
     D                                           wsdl_contentTransferEncoding_t)
     D                                           options(*nopass: *omit)
     D  i_suggestedFileName...
     D                                     const like(wsdl_path_t)
     D                                           options(*nopass: *omit)
      *
      *  Return value
     D partID          S                   like(wsdl_partID_t) inz
      *
      *  Parameter positions
     D p_transferEncoding...
     D                 C                   3
     D p_suggestedFileName...
     D                 C                   4
      *
      *  Optional parameters
     D transferEncoding...
     D                 S                   like(i_transferEncoding)
     D suggestedFileName...
     D                 S                   like(i_suggestedFileName)
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /free

         if (%parms() >= p_transferEncoding and
             %addr(i_transferEncoding) <> *NULL);
            transferEncoding = i_transferEncoding;
         else;
            transferEncoding = WSDL_MIME_BINARY;
         endif;

         if (%parms() >= p_suggestedFileName and
             %addr(i_suggestedFileName) <> *NULL);
            suggestedFileName = i_suggestedFileName;
         else;
            suggestedFileName = '';
         endif;

         partID = ArchiveServerPort_Attachments_addFile(
                        getMessageContext(): i_path:
                        i_contentType : transferEncoding: suggestedFileName);

         return partID;

      /end-free
     P                 E
      *
      * =====================================================================
      * This procedure adds a buffer attachment. The attachment
      * is sent to the server the next time the web service is called.
      *
      * Parameters:
      *  i_suggestedFileName    Is the suggested file for saving the
      *                         attachment. Goes into the
      *                         'Content-Disposition header', attribute 'filename'.
      *                         The content disposition is always 'attachment'.
      *
      *  i_pBuffer              Buffer, containing the attachment data.
      *
      *  i_size                 Size of the buffer.
      *
      *  i_contentType          Specifies the type of the MIME data.
      *
      *  i_transferEncoding     Specifies the encoding of the MIME data.
      *                         Possible values are:
      *                         WSDL_MIME_BINARY - binary data, no encoding
      *                         WSDL_MIME_BASE64 - converted to base64
      *
      *  i_targetCcsid          Specifies the character encoding that the
      *                         data shall arrive on the server.
      *                         -1   - No character translation
      *                         0    - Buffer is translated to the job CCSID
      *                         >0   - CCSID the buffer is translated to,
      *                                before it is encoded to Base64 or
      *                                before it is sent to the server when
      *                                sent as binary data.
      *
      * Return value:
      *  partID                 Unique ID of the attachment. Usually this ID
      *                         is stored in the SOAP message, depending on
      *                         the description of the Web Service.
      * =====================================================================
     P ArchiveServerPort_...
     P archiveFile_...
     P Attachments_addBuffer...
     P                 B                   export
     D                 PI                        like(wsdl_partID_t)
     D  i_name                             const like(wsdl_path_t)
     D  i_pBuffer                      *   const
     D  i_size                       10I 0 const
     D  i_contentType                      const like(wsdl_contentType_t)
     D  i_transferEncoding...
     D                                     const like(
     D                                           wsdl_contentTransferEncoding_t)
     D                                           options(*nopass: *omit)
     D  i_targetCcsid                10I 0 const options(*nopass: *omit)
      *
      *  Return value
     D partID          S                   like(wsdl_partID_t) inz
      *
      *  Parameter positions
     D p_transferEncoding...
     D                 C                   5
     D p_targetCcsid   C                   6
      *
      *  Optional parameters
     D transferEncoding...
     D                 S                   like(i_transferEncoding)
     D targetCcsid     S                   like(i_targetCcsid)
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /free

         if (%parms() >= p_transferEncoding and
             %addr(i_transferEncoding) <> *NULL);
            transferEncoding = i_transferEncoding;
         else;
            transferEncoding = WSDL_MIME_BINARY;
         endif;

         if (%parms() >= p_targetCcsid and %addr(i_targetCcsid) <> *NULL);
            targetCcsid = i_targetCcsid;
         else;
            targetCcsid = -1; // binary data. no character translation.
         endif;

         partID = ArchiveServerPort_Attachments_addBuffer(
                        getMessageContext(): i_name: i_pBuffer: i_size
                        : i_contentType : transferEncoding: targetCcsid);

         return partID;

      /end-free
     P                 E
      *
      * =====================================================================
      * This procedure adds a string attachment. The attachment
      * is sent to the server the next time the web service is called.
      *
      * Parameters:
      *  i_suggestedFileName    Is the suggested file for saving the
      *                         attachment. Goes into the
      *                         'Content-Disposition header', attribute 'filename'.
      *                         The content disposition is always 'attachment'.
      *
      *  i_pBuffer              Buffer, containing the attachment data.
      *
      *  i_size                 Size of the buffer.
      *
      *  i_contentType          Specifies the type of the MIME data.
      *
      *  i_transferEncoding     Specifies the encoding of the MIME data.
      *                         Possible values are:
      *                         WSDL_MIME_BINARY - binary data, no encoding
      *                         WSDL_MIME_BASE64 - converted to base64
      *
      *  i_targetCcsid          Specifies the character encoding that the
      *                         data shall arrive on the server.
      *                         -1   - No character translation
      *                         0    - Buffer is translated to the job CCSID
      *                         >0   - CCSID the buffer is translated to,
      *                                before it is encoded to Base64 or
      *                                before it is sent to the server when
      *                                sent as binary data.
      *
      * Return value:
      *  partID                 Unique ID of the attachment. Usually this ID
      *                         is stored in the SOAP message, depending on
      *                         the description of the Web Service.
      * =====================================================================
     P ArchiveServerPort_...
     P archiveFile_...
     P Attachments_addString...
     P                 B                   export
     D                 PI                        like(wsdl_partID_t)
     D  i_name                             const like(wsdl_path_t)
     D  i_string                  32767A         varying options(*varsize)
     D  i_contentType                      const like(wsdl_contentType_t)
     D  i_transferEncoding...
     D                                     const like(
     D                                           wsdl_contentTransferEncoding_t)
     D                                           options(*nopass: *omit)
     D  i_targetCcsid                10I 0 const options(*nopass: *omit)
      *
      *  Return value
     D partID          S                   like(wsdl_partID_t) inz
      *
      *  Parameter positions
     D p_transferEncoding...
     D                 C                   4
     D p_targetCcsid   C                   5
      *
      *  Optional parameters
     D transferEncoding...
     D                 S                   like(i_transferEncoding)
     D targetCcsid     S                   like(i_targetCcsid)
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /free

         if (%parms() >= p_transferEncoding and
             %addr(i_transferEncoding) <> *NULL);
            transferEncoding = i_transferEncoding;
         else;
            transferEncoding = WSDL_MIME_BINARY;
         endif;

         if (%parms() >= p_targetCcsid and %addr(i_targetCcsid) <> *NULL);
            targetCcsid = i_targetCcsid;
         else;
            targetCcsid = -1; // binary data. no character translation.
         endif;

         partID = ArchiveServerPort_Attachments_addBuffer(
                        getMessageContext(): i_name
                        : %addr(i_string)+1: %len(i_string)
                        : i_contentType : transferEncoding: targetCcsid);

         return partID;

      /end-free
     P                 E
      *
      *
      * ==================================================================
      * Return value: tns:archiveFileResponse
      * ==================================================================
     P tns_archiveFileResponseRnmdStart...
     P                 B
     D                 PI
     D  userdata                       *   value
     D  depth                        10I 0 value
     D  namespace                  1024A   varying const
     D  name                       1024A   varying const
     D  path                      24576A   varying const
     D  attrs                          *   dim(32767)
     D                                     const options(*varsize)
      *
     D currentItem     DS                  likeds(tns_archiveFileResponseRnmd_t)
     D                                     based(pCurrentItem)
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /free

         // Get access to current item
         pCurrentItem = userdata;

         select;
         when (depth = 1);
            if (MultiRef_isReference(attrs));
               MultiRef_put(
                  attrs
                  : XMLSAXParser_getUserData()
                  : depth
                  : namespace
                  : name
                  : path
                  : XMLSAXParser_getStartCallback()
                  : XMLSAXParser_getEndCallback()
                  : *omit
                  : %addr(currentItem)
                  : %size(currentItem)
                  );
            endif;
            return;

         when (depth = 2
                and
                name = 'return');
            // Value is retrieved in corresponding END procedure
            if (MultiRef_isReference(attrs));
               MultiRef_put(
                  attrs
                  : XMLSAXParser_getUserData()
                  : depth
                  : namespace
                  : name
                  : path
                  : XMLSAXParser_getStartCallback()
                  : XMLSAXParser_getEndCallback()
                  : *omit
                  : %addr(currentItem.return)
                  : %size(currentItem.return)
                  );
            endif;
            return;

         endsl;

      /end-free
      *
     P                 E
      *
      * ==================================================================
      * Return value: tns:archiveFileResponse
      * ==================================================================
     P tns_archiveFileResponseRnmdEnd...
     P                 B
     D                 PI
     D  userdata                       *   value
     D  depth                        10I 0 value
     D  namespace                  1024A   varying const
     D  name                       1024A   varying const
     D  path                      24576A   varying const
     D  value                     65535A   varying
     D  attrs                          *   dim(32767)
     D                                     const options(*varsize)
      *
     D currentItem     DS                  likeds(tns_archiveFileResponseRnmd_t)
     D                                     based(pCurrentItem)
      *
     D itemValue       DS                  likeds(wsdl_fullElementData_t)
     D                                     inz
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /free

         // Get access to current item
         pCurrentItem = userdata;

         // Get full element data
         itemValue = XMLSAXParser_getFullElementData();

         select;
         when (depth = 2
                and
                name = 'return');
            if (not Value_isNil(attrs));
               UnMarshaller_setFieldIdentifier(name: path);
               UnMarshaller_toStringV6(
                  %addr(currentItem.return)
                  : %addr(currentItem.return: *DATA)
                  : %size(currentItem.return)
                  : itemValue.pData
                  : itemValue.size);
            endif;

         endsl;

      /end-free
      *
     P                 E
      *
      * =====================================================================
      *   Reopens a given input stream in order to send it over
      *   the wire again.
      * =====================================================================
     P reOpenInputStream...
     P                 B
     D                 PI                         like(wsdl_hStream_t    )
     D  i_hMsgCtx                          const  like(wsdl_hMsgCtx_t    )
     D  i_hInpStream                       value  like(wsdl_hStream_t    )
      *
      *  Return value
     D hInpStream      S                   like(wsdl_hStream_t       ) inz
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /free

         MessageContext_InputStream_close(i_hInpStream);
         hInpStream = MessageContext_InputStream_open(i_hMsgCtx);

         return hInpStream;

      /end-free
     P                 E
      *
      * =====================================================================
      *   Login in to proxy server or http server.
      *   Returns WSDL_SUCCESS on success, else WSDL_ERROR.
      * =====================================================================
     P login...
     P                 B
     D                 PI            10I 0
      *
      *  Return value
     D rc              S             10I 0 inz
      *
      *  Local fields
     D currErr         S             10I 0 inz
      *
      *  Local fields (static)
     D lastErr         S             10I 0 inz static
     D numAttempts     S             10I 0 inz static
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /free

         http_DebugLog_appendText(
         '** ' + %char(%timestamp()) + ': Requesting user name and password');

         http_error(currErr);                // Keep track of the number
         if (currErr <> lastErr);            // of failed login attempts.
            lastErr = currErr;
            numAttempts = 1;
         else;
            numAttempts = numAttempts + 1;
         endif;

         rc = ArchiveServerPort_Port_login(
                    currErr: numAttempts);

         return rc;

      /end-free
     P                 E
      *
      * =====================================================================
      *   Sets the content type and the SOAP action of the POST message.
      * =====================================================================
     P HTTP_setContentTypeAndSOAPAction...
     P                 B
     D                 PI
     D  o_addlHdrs                 1024A          varying
     D  i_pUserData                    *   value
      *
      *  User Data
     D headers         DS                  likeds(headers_t) based(i_pUserData)
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /free

         if (headers.mimeVersion <> '');
            o_addlHdrs = headers.mimeVersion;
         else;
            o_addlHdrs = '';
         endif;

         o_addlHdrs = o_addlHdrs + headers.contentType + headers.soapAction;

      /end-free
     P                 E
      *
      * =====================================================================
      *   Receive response of HTTP post operation.
      * =====================================================================
     P HTTP_receiveResponse...
     P                 B
     D                 PI            10I 0
     D  i_hStream                    10I 0 value
     D  i_data                         *   value
     D  i_length                     10I 0 value
      *
     D rc              S             10I 0 inz(-1)
     D contentType     S           1024A   inz
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /free

         http_DebugLog_appendTextVerbose(
         '** ' + %char(%timestamp()) + ': Entering ' + f_this() + '()');

         if (not g_HTTP_isInit);
            http_DebugLog_appendText(
            '** '+%char(%timestamp())+': Preparing to parse received message');
            select;
            when (http_getContentType() = 'text');
               if (http_getContentSubType() = 'html');
                  if (f_exist('WSDL2RPG': '*LIBL': '*MSGF'));
                     clear USR0030;
                     USR00301 = getPortName();
                     AppMsg_sendCancelMsg(AppMsg_newError('USR0030': USR0030));
                  else;
                     AppMsg_sendCancelMsg(
                        f_newMsg('CPF9898'
                              : 'Unexpected HTML data received from web service'
                              : '*ESCAPE'
                              : 'QCPFMSG'));
                  endif;
               endif;
            when (http_getContentType() = 'multipart');
               contentType = %trim(http_header('content-type'));
               MIMEParser_beginParse(g_hMIMEParser);
               MIMEParser_setContentType(g_hMIMEParser: contentType);
               g_SOAPMessageID = http_getContentTypeAttr('start': cTrue);
               g_isMimeMessage = cTrue;
               http_DebugLog_appendText(
               '** ' + %char(%timestamp()) + ': Detected MIME message');
            endsl;
            g_HTTP_isInit = cTrue;
         endif;

         if (g_isMimeMessage);
            if (MIMEParser_parse(g_hMIMEParser: i_data: i_length) = cTrue);
               rc = i_length;
            else;
               rc = -1;
               http_DebugLog_appendText(
               '** '+ %char(%timestamp()) +': Failed parsing MIME message');
            endif;
         else;
            if (parseOrRedirectResponse(i_data: i_length) = cTrue);
               rc = i_length;
            else;
               rc = -1;
               http_DebugLog_appendText(
               '** '+ %char(%timestamp()) +': Failed parsing XML message');
            endif;
         endif;

         http_DebugLog_appendTextVerbose(
         '** ' + %char(%timestamp()) + ': Leaving ' + f_this() + '()');

         return rc;

      /end-free
     P                 E
      *
      * =====================================================================
      *   Parses or redirects the web service response.
      * =====================================================================
     P parseOrRedirectResponse...
     P                 B
     D                 PI              N
     D  i_data                         *   value
     D  i_length                     10I 0 value
      *
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /free

         if (ArchiveServerPort_RedirectResponse_isActive());
            // Append HTTP response to output file
            if (not ArchiveServerPort_RedirectResponse_write(
                          i_data: i_length));
               http_DebugLog_appendText(
               '** '+ %char(%timestamp()) +': Failed to redirect +
                                              XML message');
               return cFalse;
            endif;
         else;
            // Parse HTTP response
            if (not XMLSAXParser_parse(g_hSAXParser: i_data: i_length) = cTrue);
               http_DebugLog_appendText(
               '** '+ %char(%timestamp()) +': Failed parsing XML message');
               return cFalse;
            endif;
         endif;

         return cTrue;

      /end-free
     P                 E
      *
      * =====================================================================
      *   Starts a MIME body part.
      *   This procedure is called whenever a new part is started.
      * =====================================================================
      *   Parameters:
      *     i_pPart            Handle of the current part.
      *     i_pUserData        Pointer to user data as specified at
      *                        http_mime_DataSink_initialize().
      * =====================================================================
     P HTTPDataSink_startPart...
     P                 B
     D                 PI
     D  i_pPart                        *   const
     D  i_pUserData                    *   const
      *
     D contentID       S            512A   varying inz
     D contentSubType  S             16A   varying inz
      *
      * -------------------------------------------
      *  TODO: Add fields to open
      *        the file and to store the
      *        file descriptor.
      * -------------------------------------------
      /IF DEFINED(DEFAULT_ATTACHMENT_HANDLING)
     D contentType     S             10I 0 inz
     D fileName        S           1024A   varying inz
     D fileExt         S             10A   varying inz
      *
     D partUserData    DS                  likeds(partUserData_t )
     D                                     based(pPartUserData)
      /ENDIF
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /free

         if (http_mime_Part_getType(i_pPart) <> cMIME_BASICPART);
            return;
         endif;

         g_BodyPart_counter = g_BodyPart_counter + 1;

         contentID      = http_mime_Part_getContentID(i_pPart);
         contentSubType = http_mime_Part_getContentSubType(i_pPart);

         if (not g_SOAPMessage_done);
            if (g_SOAPMessageID <> '');
               if (contentSubType = 'xml' and contentID = g_SOAPMessageID);
                  g_doParseSOAPMessage = cTrue;
                  return;
               endif;
            else;
               if (g_BodyPart_counter = 1);
                  g_doParseSOAPMessage = cTrue;
                  return;
               endif;
            endif;
         endif;

         // -----------------------------------------
         // TODO:
         // Add your code to handle attachments here!
         // E.g.: Open output file.
         // -----------------------------------------
      /IF DEFINED(DEFAULT_ATTACHMENT_HANDLING)

         // Ignore all attachments that are not a BasicPart
         if (http_mime_Part_getType(i_pPart) <> cMIME_BASICPART);
            return;
         endif;

         fileName       = http_mime_Part_getFileName(i_pPart);
         contentID      = http_mime_Part_getContentID(i_pPart);
         contentType    = http_mime_Part_getContentType(i_pPart);
         contentSubType = http_mime_Part_getContentSubType(i_pPart);

         if (contentType = cMIME_TYPE_TEXT);
            fileExt = 'txt';
         else;
            fileExt = contentSubType;
         endif;

         fileName = ArchiveServerPort_Attachments_getFolder()
                    + %char(%timestamp()) + '_' + contentID + '_'
                    + fileName  + '.' + fileExt;
         fileName = %xlate(':<>': '___': fileName);

         // Assign filename to content-ID and put it into the list of attachments
         ArchiveServerPort_Attachments_put(
               contentID
               : fileName
               : getOperationUuid());

         // Produce the user data of that Part to
         // store the file descriptor of the open file.
         pPartUserData = %alloc(%size(partUserData_t));
         clear partUserData;

         partUserData.FD = open(fileName
                                : O_CREAT + O_EXCL +
                                  O_SHARE_RDONLY + O_WRONLY + O_CCSID
                                : S_IRWXU + S_IRWXG + S_IRWXO
                                : 819);   // CCSID does not matter because
                                          // we write binary data

         // Set user data of the current Part.
         http_mime_Part_setUserData(i_pPart: pPartUserData);
      /ENDIF

         return;

      /end-free
     P                 E
      *
      * =====================================================================
      *   Receives MIME part body data.
      *   This procedure is called whenever new body data is available.
      * =====================================================================
      *   Parameters:
      *     i_pPart            Handle of the current part.
      *     i_pUserData        Pointer to user data as specified at
      *                        http_mime_DataSink_initialize().
      *     i_data             Pointer to decoded body data.
      *     i_size             Size of decoded body data.
      * =====================================================================
     P HTTPDataSink_bodyData...
     P                 B
     D                 PI
     D  i_pPart                        *   const
     D  i_pUserData                    *   const
     D  i_data                         *   const
     D  i_size                       10I 0 const
      *
      * -------------------------------------------
      *  TODO: Add fields to write
      *        the attachment to the file
      *        opened in HTTPDataSink_startPart().
      * -------------------------------------------
      /IF DEFINED(DEFAULT_ATTACHMENT_HANDLING)
     D rc              S             10I 0 inz
      *
     D partUserData    DS                  likeds(partUserData_t )
     D                                     based(pPartUserData)
      /ENDIF
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /free

         if (g_doParseSOAPMessage);
            parseOrRedirectResponse(i_data: i_size);
            return;
         endif;

         // -----------------------------------------
         // TODO:
         // Add your code to handle attachments here!
         // E.g.: Write received data to output file.
         // -----------------------------------------

      /IF DEFINED(DEFAULT_ATTACHMENT_HANDLING)
         // Gain access to the user data of the current Part.
         pPartUserData = http_mime_Part_getUserData(i_pPart);
         if (pPartUserData = *NULL);
            return;
         endif;

         // Return to caller if no file is open.
         if (partUserData.FD <= 0);
            return;
         endif;

         // Append attachment data to the file.
         rc = write(partUserData.FD: i_data: i_size);
      /ENDIF

         return;

      /end-free
     P                 E
      *
      * =====================================================================
      *   Ends a MIME body part.
      *   This procedure is called whenever a new part ends.
      * =====================================================================
      *   Parameters:
      *     i_pPart            Handle of the current part.
      *     i_pUserData        Pointer to user data as specified at
      *                        http_mime_DataSink_initialize().
      * =====================================================================
     P HTTPDataSink_endPart...
     P                 B
     D                 PI
     D  i_pPart                        *   const
     D  i_pUserData                    *   const
      *
      * -------------------------------------------
      *  TODO: Add fields to close the file
      *        opened in HTTPDataSink_startPart().
      * -------------------------------------------
      /IF DEFINED(DEFAULT_ATTACHMENT_HANDLING)
     D rc              S             10I 0 inz
      *
     D partUserData    DS                  likeds(partUserData_t )
     D                                     based(pPartUserData)
      /ENDIF
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /free

         if (http_mime_Part_getType(i_pPart) <> cMIME_BASICPART);
            return;
         endif;

         if (g_doParseSOAPMessage);
            g_doParseSOAPMessage = cFalse;
            g_SOAPMessage_done   = cTrue;
            return;
         endif;

         // -----------------------------------------
         // TODO:
         // Add your code to handle attachments here!
         // E.g.: Close output file.
         // -----------------------------------------
      /IF DEFINED(DEFAULT_ATTACHMENT_HANDLING)

         // Gain access to the user data of the current Part.
         pPartUserData = http_mime_Part_getUserData(i_pPart);
         if (pPartUserData = *NULL);
            return;
         endif;

         // Return to caller if no file is open.
         if (partUserData.FD <= 0);
            return;
         endif;

         // Close the file.
         callp close(partUserData.FD);
         partUserData.FD = 0;

         // Free memory allocated in HTTPDataSink_startPart()
         dealloc(N) pPartUserData;
      /ENDIF

         return;

      /end-free
     P                 E
      *
      * =====================================================================
      *   SOAP message: Envelope
      * =====================================================================
     P SOAPMessage_Envelope...
     P                 B
     D                 PI
     D   userdata                      *   value
     D   depth                       10I 0 value
     D   namespace                 1024A   varying const
     D   name                      1024A   varying const
     D   path                     24576A   varying const
     D   attrs                         *   dim(32767)
     D                                     const options(*varsize)
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /free

         if (depth = 1 and f_lcase(name) = 'html');
            if (f_exist('WSDL2RPG': '*LIBL': '*MSGF'));
               clear USR0030;
               USR00301 = getPortName();
               AppMsg_sendCancelMsg(AppMsg_newError('USR0030': USR0030));
            else;
               AppMsg_sendCancelMsg(
                     f_newMsg('CPF9898'
                              : 'Unexpected HTML data received from web service'
                              : '*ESCAPE'
                              : 'QCPFMSG'));
            endif;
         endif;

         select;
         when (path = '/Envelope/Header');
            XMLSAXParser_delegateElementProcessing(
               g_pRespSoapHeader
               : %paddr('SOAPMessage_unexpectedElementStart')
               : %paddr('SOAPMessage_unexpectedElementEnd'));
           return;

         when (path = '/Envelope/Body');

            select;
            when (name = 'Fault');
               XMLSAXParser_delegateElementProcessing(
                  %addr(g_errors.soapFault)
                  : %paddr('SOAPMessage_FaultStart')
                  : %paddr('SOAPMessage_FaultEnd'));
              return;

            when (MultiRef_isData(attrs));
               XMLSAXParser_delegateElementProcessing(
                  *NULL
                  : MultiRef_getStartCallback()
                  : MultiRef_getEndCallback());
               return;

            other;
               XMLSAXParser_delegateElementProcessing(
                  userdata
                  : %paddr('tns_archiveFileResponseRnmdStart')
                  : %paddr('tns_archiveFileResponseRnmdEnd'));
              return;
            endsl;

         endsl;

         return;

      /end-free
     P                 E
      *
      * =====================================================================
      *   SOAP message: fault information
      * =====================================================================
     P SOAPMessage_FaultStart...
     P                 B
     D                 PI
     D   userdata                      *   value
     D   depth                       10I 0 value
     D   namespace                 1024A   varying const
     D   name                      1024A   varying const
     D   path                     24576A   varying const
     D   attrs                         *   dim(32767)
     D                                     const options(*varsize)
      *
     D fault...
     D                 DS                  based(userdata)
     D                                     likeds(wsdl_soapFault_t )
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /free

         if (depth = 1);
            g_errors.errType = WSDL_HTTP_ERROR_SOAP;
            g_errors.soapFault.code = 'WSDL2RPG';
            g_errors.soapFault.string = 'WSDL2RPG: Unspecified SOAP error';
            return;
         endif;

         select;
         when (name = 'detail');
            XMLSAXParser_delegateElementProcessing(
               %addr(fault.detail)
               : %paddr('SOAPMessage_FaultDetailStart')
               : %paddr('SOAPMessage_FaultDetailEnd'));
         endsl;

      /end-free
     P                 E
      *
      * =====================================================================
      *   SOAP message: fault information
      * =====================================================================
     P SOAPMessage_FaultEnd...
     P                 B
     D                 PI
     D   userdata                      *   value
     D   depth                       10I 0 value
     D   namespace                 1024A   varying const
     D   name                      1024A   varying const
     D   path                     24576A   varying const
     D   value                    65535A   varying const
     D   attrs                         *   dim(32767)
     D                                     const options(*varsize)
      *
     D fault...
     D                 DS                  based(userdata)
     D                                     likeds(wsdl_soapFault_t )
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /free

         if (depth = 1);
            return;
         endif;

         select;
         when (name = 'faultcode');
            fault.code = value;
         when (name = 'faultstring');
            fault.string = value;
         endsl;

      /end-free
     P                 E
      *
      * =====================================================================
      *   SOAP message: fault details
      * =====================================================================
     P SOAPMessage_FaultDetailStart...
     P                 B
     D                 PI
     D   userdata                      *   value
     D   depth                       10I 0 value
     D   namespace                 1024A   varying const
     D   name                      1024A   varying const
     D   path                     24576A   varying const
     D   attrs                         *   dim(32767)
     D                                     const options(*varsize)
      *
     D detail...
     D                 DS                  based(userdata)
     D                                     likeds(wsdl_soap_faultDetail_t)
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /free

         if (depth = 1);
            return;
         endif;

         select;
         endsl;

      /end-free
     P                 E
      *
      * =====================================================================
      *   SOAP message: fault details
      * =====================================================================
     P SOAPMessage_FaultDetailEnd...
     P                 B
     D                 PI
     D   userdata                      *   value
     D   depth                       10I 0 value
     D   namespace                 1024A   varying const
     D   name                      1024A   varying const
     D   path                     24576A   varying const
     D   value                    65535A   varying const
     D   attrs                         *   dim(32767)
     D                                     const options(*varsize)
      *
     D detail...
     D                 DS                  based(userdata)
     D                                     likeds(wsdl_soap_faultDetail_t)
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /free

         if (depth = 1);
            return;
         endif;

         select;
         when (name = 'hostname');
            detail.hostname = value;
         endsl;

      /end-free
     P                 E
      *
      * =====================================================================
      *   SOAP message: NULL callback procedure
      * =====================================================================
     P SOAPMessage_unexpectedElementStart...
     P                 B
     D                 PI
     D   userdata                      *   value
     D   depth                       10I 0 value
     D   namespace                 1024A   varying const
     D   name                      1024A   varying const
     D   path                     24576A   varying const
     D   attrs                         *   dim(32767)
     D                                     const options(*varsize)
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /free

         if (ignoreUnexpectedSoapHeader());
            http_DebugLog_appendText(
               'Warning: Received unexpected Soap header: <' + name + '>');
            return;
         endif;

         if (f_exist('WSDL2RPG': '*LIBL': '*MSGF'));
            clear USR0042;
            USR00421 = 'SOAPMessage_unexpectedElementStart';
            USR00422 = 'SOAPMessage_unexpectedElementEnd';
            AppMsg_sendCancelMsg(AppMsg_newError('USR0042': USR0042));
         else;
            AppMsg_sendCancelMsg(
               f_newMsg('CPF9898'
                     : 'Unexpected Soap element received from web service.'
                     : '*ESCAPE'
                     : 'QCPFMSG'));
         endif;

         return;

      /end-free
     P                 E
      *
      * =====================================================================
      *   SOAP message: NULL callback procedure
      * =====================================================================
     P SOAPMessage_unexpectedElementEnd...
     P                 B
     D                 PI
     D   userdata                      *   value
     D   depth                       10I 0 value
     D   namespace                 1024A   varying const
     D   name                      1024A   varying const
     D   path                     24576A   varying const
     D   value                    65535A   varying const
     D   attrs                         *   dim(32767)
     D                                     const options(*varsize)
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /free

         if (ignoreUnexpectedSoapHeader());
            http_DebugLog_appendText(
               'Warning: Received unexpected Soap header: ' + value);
            http_DebugLog_appendText(
               'Warning: Received unexpected Soap header: </' + name + '>');
            return;
         endif;

         if (f_exist('WSDL2RPG': '*LIBL': '*MSGF'));
            clear USR0042;
            USR00421 = 'SOAPMessage_unexpectedElementStart';
            USR00422 = 'SOAPMessage_unexpectedElementEnd';
            AppMsg_sendCancelMsg(AppMsg_newError('USR0042': USR0042));
         else;
            AppMsg_sendCancelMsg(
               f_newMsg('CPF9898'
                     : 'Unexpected Soap element received from web service.'
                     : '*ESCAPE'
                     : 'QCPFMSG'));
         endif;

         return;

      /end-free
     P                 E
      *
      * =====================================================================
      *   Specifies, whether unexpected Soap headers are ignored or not.
      * =====================================================================
     P ignoreUnexpectedSoapHeader...
     P                 B
     D                 PI              N
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /free

         return cFalse;

      /end-free
     P                 E
      *
      * =====================================================================
      *   Returns the UUID of this web service operation.
      *   All attachments and allocated memory block are attached to
      *   this UUID.
      * =====================================================================
     P getOperationUuid...
     P                 B
     D                 PI                          like(wsdl_uuid_t )
      *
      *  Return value
     D uuid            S                   like(wsdl_uuid_t ) inz
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /free

         uuid = ArchiveServerPort_Port_getUuid();

         return uuid;

      /end-free
     P                 E
      *
      * =====================================================================
      *   Returns the name of the web service port.
      * =====================================================================
     P getPortName...
     P                 B
     D                 PI                          like(wsdl_portName_t )
      *
      *  Return value
     D name            S                   like(wsdl_portName_t ) inz
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /free

         name = ArchiveServerPort_Port_getName();

         return name;

      /end-free
     P                 E
      *
      * =====================================================================
      *   Returns the name of this web service operation.
      * =====================================================================
     P getOperationName...
     P                 B
     D                 PI                          like(wsdl_operName_t )
      *
      *  Return value
     D name            S                   like(wsdl_operName_t ) inz
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /free

         name = 'archiveFile';

         return name;

      /end-free
     P                 E
      *
      * =====================================================================
      *   Returns the CCSID of the remote POST data.
      * =====================================================================
     P getPostCcsid...
     P                 B
     D                 PI            10I 0
      *
      *  Return value
     D post_ccsid      S             10I 0 inz(1208)
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /free

         post_ccsid = ArchiveServerPort_Port_getPostCcsid();

         return post_ccsid;

      /end-free
     P                 E
      *
      * =====================================================================
      *   Returns the XML encoding used for the SOAP message.
      * =====================================================================
     P getPostCcsidXml...
     P                 B
     D                 PI            20A   varying
      *
      *  Return value
     D post_ccsid_xml  S             20A   varying inz
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /free

         post_ccsid_xml = ArchiveServerPort_Port_getPostCcsidXml();

         return post_ccsid_xml;

      /end-free
     P                 E
      *
      * =====================================================================
      *   Returns the timeout in seconds that HTTPAPI waits
      *   for a connection to the server.
      * =====================================================================
     P getTimeout...
     P                 B
     D                 PI            10I 0
      *
      *  Return value
     D timeoutSecs     S             10I 0 inz(HTTP_TIMEOUT)
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /free

         timeoutSecs = ArchiveServerPort_Port_getTimeout();

         return timeoutSecs;

      /end-free
     P                 E
      *
      * =====================================================================
      *   Returns the user agent identification used by HTTPAPI
      *   to identify the client to the server.
      * =====================================================================
     P getUserAgent...
     P                 B
     D                 PI                         like(wsdl_userAgent_t )
      *
      *  Return value
     D userAgent       S                   like(wsdl_userAgent_t )
     D                                     inz(HTTP_USERAGENT)
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /free

         userAgent = ArchiveServerPort_Port_getUserAgent();

         return userAgent;

      /end-free
     P                 E
      *
      * =====================================================================
      *   Returns the message context. The context is created if
      *   it does not yet exist.
      * =====================================================================
     P getMessageContext...
     P                 B
     D                 PI                         like(wsdl_hMsgCtx_t)
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /free

         if (MessageContext_isNull(g_hMsgCtx));
            g_hMsgCtx = MessageContext_new(cTrue);
         endif;

         return g_hMsgCtx;

      /end-free
     P                 E
      *
      * =====================================================================
      *   Returns cTrue if the response must be redirected to a stream
      *   file, otherwise cFalse.
      * =====================================================================
     P mustRedirectStmf...
     P                 B
     D                 PI              N
      *
      *  Return value
     D mustRedirectStmf...
     D                 S               N   inz(cFalse)
      * - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      /free

         mustRedirectStmf =
            ArchiveServerPort_RedirectResponse_isActive();

         return mustRedirectStmf;

      /end-free
     P                 E
      *
